---
phase: 04-core-features
plan: 01
type: execute
---

<objective>
Create a tenant-aware API helper and update all booking API routes to use tenant context.

Purpose: Enable multi-tenant data isolation for booking operations without modifying database schemas.
Output: 6 booking API routes that query tenant-specific schemas via X-Tenant-Slug header.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-auth-onboarding/03-01-SUMMARY.md

**Key files:**
@lib/tenant/context.ts - Has getTenantFromRequest(), tenantQuery(), tenantMutate()
@lib/db.ts - Has tenantQuery(), tenantQueryOne(), tenantMutate() functions
@app/api/autow/booking/list/route.ts - Example of current pattern using query()

**Tech stack available:**
- TenantContext with getTenantFromRequest()
- tenantQuery(), tenantQueryOne(), tenantMutate() for schema-scoped queries
- X-Tenant-Slug header for API tenant identification

**CRITICAL: No schema modifications**
- Do NOT create migrations
- Do NOT alter any tables
- Only change how queries are executed (SET search_path is session-level)
- Existing public schema tables remain untouched

**Pattern to follow:**
```typescript
// OLD (queries public schema)
import { query } from '@/lib/db';
const result = await query('SELECT * FROM bookings');

// NEW (queries tenant schema)
import { getTenantFromRequest, tenantQuery } from '@/lib/tenant/context';
const tenant = await getTenantFromRequest(request);
if (!tenant) return NextResponse.json({ error: 'Tenant not found' }, { status: 400 });
const rows = await tenantQuery(tenant, 'SELECT * FROM bookings');
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tenant API helper utility</name>
  <files>lib/api/withTenant.ts</files>
  <action>
Create a helper function that wraps API route handlers with tenant context extraction.

```typescript
// lib/api/withTenant.ts
import { NextRequest, NextResponse } from 'next/server';
import { getTenantFromRequest } from '@/lib/tenant/context';
import { TenantContext } from '@/lib/tenant/types';

export async function withTenant(
  request: NextRequest,
  handler: (tenant: TenantContext, request: NextRequest) => Promise<NextResponse>
): Promise<NextResponse> {
  const tenant = await getTenantFromRequest(request);

  if (!tenant) {
    return NextResponse.json(
      { error: 'Tenant not found. Include X-Tenant-Slug header.' },
      { status: 400 }
    );
  }

  return handler(tenant, request);
}
```

This utility:
- Extracts tenant from X-Tenant-Slug header
- Returns 400 if tenant not found
- Passes tenant context to handler
- Reduces boilerplate in each route
  </action>
  <verify>File exists and TypeScript compiles: `npx tsc --noEmit lib/api/withTenant.ts`</verify>
  <done>withTenant helper created with proper types and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Update booking API routes to use tenant context</name>
  <files>
    app/api/autow/booking/list/route.ts,
    app/api/autow/booking/get/route.ts,
    app/api/autow/booking/create/route.ts,
    app/api/autow/booking/update/route.ts,
    app/api/autow/booking/delete/route.ts,
    app/api/autow/booking/complete/route.ts
  </files>
  <action>
Update each booking route to:
1. Import getTenantFromRequest and tenantQuery/tenantMutate from '@/lib/tenant/context'
2. Extract tenant from request header
3. Replace query() calls with tenantQuery() or tenantMutate()
4. Keep existing auth token validation (verifyToken)

Example transformation for list route:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getTenantFromRequest, tenantQuery } from '@/lib/tenant/context';
import { verifyToken } from '@/lib/auth';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    // Auth check
    const rawAuth = request.headers.get('authorization');
    const token = rawAuth ? rawAuth.replace('Bearer ', '') : null;
    if (!verifyToken(token)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Tenant check
    const tenant = await getTenantFromRequest(request);
    if (!tenant) {
      return NextResponse.json({ error: 'Tenant required' }, { status: 400 });
    }

    // Query tenant schema
    const bookings = await tenantQuery(
      tenant,
      `SELECT * FROM bookings WHERE booking_date >= CURRENT_DATE ORDER BY booking_date, booking_time`
    );

    return NextResponse.json({ success: true, bookings });
  } catch (error) {
    console.error('List bookings error:', error);
    return NextResponse.json({ error: 'Failed to fetch bookings' }, { status: 500 });
  }
}
```

Apply same pattern to all 6 routes:
- list: tenantQuery for SELECT
- get: tenantQuery for SELECT with params
- create: tenantMutate for INSERT RETURNING
- update: tenantMutate for UPDATE
- delete: tenantMutate for DELETE
- complete: tenantMutate for UPDATE status
  </action>
  <verify>
Build succeeds: `npm run build`
No TypeScript errors in booking routes
  </verify>
  <done>All 6 booking routes use tenant context, queries scoped to tenant schema</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] No TypeScript errors
- [ ] withTenant helper exists at lib/api/withTenant.ts
- [ ] All 6 booking routes import from '@/lib/tenant/context'
- [ ] No routes still use `import { query } from '@/lib/db'` for booking operations
</verification>

<success_criteria>
- withTenant helper created for future route conversions
- All 6 booking API routes updated to tenant-aware pattern
- Build passes without errors
- No database schema modifications made
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-features/04-01-SUMMARY.md`
</output>
