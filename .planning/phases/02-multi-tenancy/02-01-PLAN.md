# Plan 02-01: Multi-Tenancy Architecture

## Objective

Implement schema-per-tenant database isolation with tenant identification middleware, enabling complete data separation between businesses while sharing a single Supabase project.

## Execution Context

**Phase**: 2 of 8 (Multi-Tenancy Architecture)
**Research Required**: Yes (Supabase multi-tenancy patterns, RLS policies)
**Estimated Scope**: Medium-Large (8 tasks, architectural changes)

**Current State**:
- Single-tenant schema with tables: bookings, estimates, invoices, receipts, notes, etc.
- All tables in public schema
- No tenant awareness

**Target State**:
- Master `tenants` table in public schema
- Each tenant gets own PostgreSQL schema (e.g., `tenant_abc123`)
- All business tables cloned into tenant schemas
- Middleware identifies tenant from subdomain/path
- All queries scoped to tenant schema

## Research Notes

### Schema-Per-Tenant Pattern

**Approach**: Each tenant gets their own PostgreSQL schema containing all business tables.

```
public schema:
  - tenants (master registry)
  - subscriptions
  - users (with tenant_id reference)

tenant_abc123 schema:
  - bookings
  - estimates
  - invoices
  - receipts
  - notes
  - jotter_notes
  - etc.
```

**Pros**:
- Complete data isolation
- Easy backup/restore per tenant
- No RLS complexity for tenant data
- Can query across tenants from public schema if needed

**Cons**:
- Schema creation on signup (automated)
- Migrations must apply to all tenant schemas
- Slightly more complex connection handling

### Supabase Considerations

- Supabase supports multiple schemas
- Use `SET search_path` to switch contexts
- Service role key needed for schema operations
- RLS can be minimal (schema provides isolation)

## Tasks

### Task 1: Create Master Tenants Table

Create the central tenant registry in public schema.

```sql
-- database/migrations/001_create_tenants.sql
CREATE TABLE IF NOT EXISTS public.tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug VARCHAR(50) UNIQUE NOT NULL,  -- URL-safe identifier
    business_name VARCHAR(255) NOT NULL,
    trade_type VARCHAR(50) NOT NULL,  -- car_mechanic, plumber, electrician, builder, general

    -- Contact
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(20),

    -- Branding (Phase 7)
    logo_url TEXT,
    primary_color VARCHAR(7) DEFAULT '#3B82F6',

    -- Subscription
    subscription_tier VARCHAR(20) NOT NULL DEFAULT 'trial',  -- trial, starter, pro, business, enterprise
    trial_ends_at TIMESTAMP,
    subscription_status VARCHAR(20) DEFAULT 'active',  -- active, past_due, cancelled
    stripe_customer_id VARCHAR(255),
    stripe_subscription_id VARCHAR(255),

    -- Terminology customization
    parts_label VARCHAR(50) DEFAULT 'Parts',  -- Parts, Materials, Components, Supplies, Items

    -- Schema
    schema_name VARCHAR(63) NOT NULL,  -- PostgreSQL schema name

    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tenants_slug ON public.tenants(slug);
CREATE INDEX idx_tenants_email ON public.tenants(email);
```

**Verification**: Table exists in public schema with all columns

---

### Task 2: Create Tenant Schema Template

Create a SQL template that will be executed when a new tenant signs up.

```sql
-- database/tenant-schema-template.sql
-- Variables: {{SCHEMA_NAME}}

CREATE SCHEMA IF NOT EXISTS {{SCHEMA_NAME}};

-- Bookings
CREATE TABLE {{SCHEMA_NAME}}.bookings (
    id SERIAL PRIMARY KEY,
    -- ... (copy from existing schema)
);

-- Estimates
CREATE TABLE {{SCHEMA_NAME}}.estimates (
    id SERIAL PRIMARY KEY,
    -- ... (copy from existing schema)
);

-- Invoices, Receipts, Notes, etc.
-- ... all tables from existing schema
```

**Verification**: Template file created with all tables

---

### Task 3: Create Tenant Provisioning Function

Create a PostgreSQL function or API endpoint to provision new tenant schemas.

```typescript
// lib/tenant-provisioning.ts
export async function provisionTenantSchema(tenantId: string, schemaName: string) {
    // 1. Read template SQL
    // 2. Replace {{SCHEMA_NAME}} with actual schema name
    // 3. Execute SQL to create schema and tables
    // 4. Return success/failure
}
```

**Verification**: Function can create new schema with all tables

---

### Task 4: Create Tenant Context Middleware

Implement middleware to identify tenant from request and set database context.

```typescript
// lib/tenant-context.ts
export interface TenantContext {
    id: string;
    slug: string;
    schemaName: string;
    tradeTtype: string;
    subscriptionTier: string;
    partsLabel: string;
}

export async function getTenantFromRequest(request: Request): Promise<TenantContext | null> {
    // Option 1: From subdomain (tenant.business-dashboard.autow-services.co.uk)
    // Option 2: From path (/tenant-slug/dashboard)
    // Option 3: From header (X-Tenant-ID)
    // Option 4: From session/JWT
}

export async function withTenantSchema<T>(
    tenantContext: TenantContext,
    callback: (client: PoolClient) => Promise<T>
): Promise<T> {
    // 1. Get database connection
    // 2. SET search_path = tenant_schema, public
    // 3. Execute callback
    // 4. Reset search_path
    // 5. Return result
}
```

**Verification**: Middleware can identify tenant and set schema context

---

### Task 5: Update Database Connection Library

Modify `lib/db.ts` to support tenant-scoped queries.

```typescript
// lib/db.ts
import { getTenantContext } from './tenant-context';

export async function tenantQuery<T>(
    sql: string,
    params: any[],
    tenantContext: TenantContext
): Promise<T[]> {
    return withTenantSchema(tenantContext, async (client) => {
        const result = await client.query(sql, params);
        return result.rows;
    });
}
```

**Verification**: Queries execute in correct tenant schema

---

### Task 6: Create Tenant Identification Strategy

Implement the chosen tenant identification method.

**Recommended**: Path-based for simplicity
- `/app/[tenant]/dashboard` - tenant slug in URL
- Fallback to session for authenticated users

```typescript
// app/[tenant]/layout.tsx
export default async function TenantLayout({
    params,
    children
}: {
    params: { tenant: string };
    children: React.ReactNode;
}) {
    const tenantContext = await getTenantBySlug(params.tenant);
    if (!tenantContext) {
        notFound();
    }

    return (
        <TenantProvider value={tenantContext}>
            {children}
        </TenantProvider>
    );
}
```

**Verification**: Tenant identified from URL path

---

### Task 7: Migrate Existing Routes to Tenant-Aware Structure

Restructure the app routes to include tenant context.

**Current**: `/autow/dashboard`, `/autow/bookings`
**New**: `/app/[tenant]/dashboard`, `/app/[tenant]/bookings`

This involves:
1. Create new `app/[tenant]/` directory structure
2. Move pages from `app/autow/` to `app/[tenant]/`
3. Update all internal links
4. Update API routes to accept tenant context

**Verification**: Routes work with tenant parameter

---

### Task 8: Create Migration Script for Existing Data

If there's existing data, create a migration to move it to a tenant schema.

```typescript
// scripts/migrate-to-multi-tenant.ts
// 1. Create a default tenant (autow)
// 2. Create schema for default tenant
// 3. Move existing data to tenant schema
// 4. Verify data integrity
```

**Verification**: Existing data migrated to tenant schema

## Success Criteria

- [ ] `public.tenants` table created
- [ ] Tenant schema template ready
- [ ] Tenant provisioning function works
- [ ] Tenant context middleware identifies tenant
- [ ] Database queries execute in correct schema
- [ ] Routes restructured with `[tenant]` parameter
- [ ] Existing functionality preserved for test tenant

## Output

After this plan completes:
- Multi-tenant database architecture in place
- Tenant identification working
- Ready for Phase 3 (Authentication & Onboarding)

## Checkpoints

| After Task | Checkpoint |
|------------|------------|
| Task 2 | Schema template complete — can provision tenants |
| Task 5 | Database layer tenant-aware — queries scoped |
| Task 7 | Routes restructured — UI works with tenants |

## Notes

- Keep existing `/autow` routes working during transition (redirect to default tenant)
- Test with a "demo" tenant first before full migration
- Document the tenant provisioning flow for Phase 3 signup
